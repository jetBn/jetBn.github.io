{"meta":{"title":"Hexo","subtitle":"","description":"","author":"jetBn","url":"http://jetBn.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-04-29T02:52:27.761Z","updated":"2020-04-29T02:52:27.761Z","comments":false,"path":"about/index.html","permalink":"http://jetbn.github.io/about/index.html","excerpt":"","text":"个人简介"},{"title":"404 Not Found：该页无法显示","date":"2020-04-28T09:38:58.115Z","updated":"2020-04-28T09:38:58.115Z","comments":false,"path":"/404.html","permalink":"http://jetbn.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-28T09:38:58.119Z","updated":"2020-04-28T09:38:58.119Z","comments":true,"path":"links/index.html","permalink":"http://jetbn.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-04-28T09:38:58.118Z","updated":"2020-04-28T09:38:58.118Z","comments":false,"path":"books/index.html","permalink":"http://jetbn.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-28T09:38:58.119Z","updated":"2020-04-28T09:38:58.119Z","comments":false,"path":"categories/index.html","permalink":"http://jetbn.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-04-28T09:38:58.120Z","updated":"2020-04-28T09:38:58.120Z","comments":false,"path":"repository/index.html","permalink":"http://jetbn.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-28T09:38:58.121Z","updated":"2020-04-28T09:38:58.121Z","comments":false,"path":"tags/index.html","permalink":"http://jetbn.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"你不知道的CSS ","slug":"不知道的CSS","date":"2020-04-30T05:42:00.000Z","updated":"2020-04-30T07:22:17.122Z","comments":true,"path":"2020/04/30/不知道的CSS/","link":"","permalink":"http://jetbn.github.io/2020/04/30/%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84CSS/","excerpt":"","text":"前言 &ensp;&ensp;&ensp;&ensp;CSS的世界是神奇的。当今所以不管移动端还是PC端网页都是离不开CSC（层叠样式表），像类选择，id选择等等这些选择器 我们工作都有用到，但是难免忽略一些，CSS中更强大的属性我们很少用到，特此记录一些。 用~/ +兄弟选择器来美化表单元素 ~选择器：查找某一个元素的后面的所有兄弟元素 +选择器：查找某一个元素的后面紧邻的兄弟元素 用font-size：0来清除间距 &ensp;&ensp;&ensp;&ensp;inline-block的元素之间会受空白区域的影响，也就是元素之间差不多会有一个字符的间隙。如果在同一行内有4个25%相同宽度的元素，会导致最后一个元素掉下来（如图）。你可以利用元素浮动float，或者压缩html，清除元素间的空格来解决。但最简单有效的方法还是设置父元素的font-size属性为0。 用 overflow 來清除浮动(创建块级格式化上下文) 通过触发BFC方式，实现清除浮动(父元素添加overflow:hidden) 12345.fahter&#123; width: 400px; border: 1px solid deeppink; overflow: hidden; &#125; 用pointer-event来禁用事件 阻止任何点击动作的执行 使链接显示为默认光标(cursor:default) 阻止触发hover和active状态 阻止JavaScript点击事件的触发 123 &#x2F;&#x2F;使用该类，任何点击事件将无效.disabled &#123; pointer-events: none; &#125; 用max-width来防止图片撑破容器 针对内容性的文案，图片大小都是未知的，为了防止图片过大而撑破容器，可以通过设置图片的max-width:100%来处理。 1234img &#123; display:inline-block; max-width: 100%; &#125; 实现三角形 新建一个元素，将它的宽高都设置为0；然后通过设置border属性来实现三角形效果 12345678910111213141516 .arrow&#123; width: 0; height: 0; &#x2F;*直角三角形*&#x2F; &#x2F;* border-width: 50px 50px 0 0; border-style: solid; border-color: transparent #000 transparent transparent; *&#x2F; &#x2F;*向下三角形*&#x2F; &#x2F;* border-width: 100px 100px 0 100px; border-style: solid; border-color: brown transparent transparent transparent; *&#x2F;&#125; 移动端禁止用户长按文字选择功能 12345678 .unselect &#123; -webkit-touch-callout:none; -webkit-user-select:none; -khtml-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none&#125; 文字模糊 1234 .blur &#123; color: transparent; text-shadow: 0 0 5px rgba(0, 0, 0, 0.5)&#125; 超出N行显示省略号 123456 .hide-text-n &#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: n; overflow: hidden&#125; 硬件加速 写transition、animation时，请用transform代替left、top等属性，从而使动画更流畅 1234567 cube &#123; -webkit-transform: translateZ(0); -moz-transform: translateZ(0); -ms-transform: translateZ(0); -o-transform: translateZ(0); transform: translateZ(0)&#125; 移动端屏幕旋转时，字体大小不改变 12345 html, body, form, p, div, h1, h2, h3, h4, h5, h6 &#123; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; text-size-adjust: 100%&#125; 锚点跳转平滑过渡 123body &#123; scroll-behavior: smooth; &#125; 最后一个元素不需要边框、边距等123ul &gt; li:not(:last-child) &#123; border-bottom: 1px solid #c5b7b7&#125; 清除浮动(适应伪类)1234567.clearfix::after &#123; content: &#39;&#39;; display: block; height: 0; visibility: hidden; clear: both&#125; CSS选择器选基数项、偶数项、倍数分组项12345678910&#x2F;* 基数 *&#x2F;.selector:nth-child(2n-1) &#123;&#125;&#x2F;* 偶数 *&#x2F;.selector:nth-child(2n) &#123;&#125;&#x2F;* 倍数分组项 *&#x2F;.selector:nth-child(3n+1) &#123;&#125; &#x2F;* 匹配第1、4、7、10... *&#x2F;.selector:nth-child(3n+5) &#123;&#125; &#x2F;* 匹配第5、8、11、14... *&#x2F;.selector:nth-child(5n-1) &#123;&#125; &#x2F;* 匹配第4、9、13、17... *&#x2F; 当输入框的value的长度不为0时，显示搜索按钮用到placeholder-shown伪类，简单来说就是当input标签有了placeholder属性并且内容不为空时，会触发该状态，但是当input标签有了value值之后，就会消除该状态，也要配合:not选择器 html 1234&lt;div class&#x3D;&quot;input-line&quot;&gt; &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入关键字进行搜索&quot;&gt; &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;search-btn&quot;&gt;搜索&lt;&#x2F;button&gt;&lt;&#x2F;div&gt; css 12345678.search-btn &#123; opacity: 0; transition: all .5s ease-in-out&#125; input:not(:placeholder-shown)~.search-btn &#123; opacity: 1 &#125;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jetbn.github.io/tags/CSS/"}],"author":"jetBn"},{"title":"Vue3.0尝试","slug":"Vue3-0尝试","date":"2020-04-29T02:59:17.000Z","updated":"2020-04-30T02:09:54.002Z","comments":true,"path":"2020/04/29/Vue3-0尝试/","link":"","permalink":"http://jetbn.github.io/2020/04/29/Vue3-0%E5%B0%9D%E8%AF%95/","excerpt":"","text":"前言 &ensp;&ensp;&ensp;&ensp;有关vue2的相关相关语法我相信大家都已经的语法我相信大家都已经会了，现在都已经2020年了vue作为前端这么热门的框架, 不去学一波对的自己是做前端的吗？哈哈哈哈🤣🤣🤣。&ensp;&ensp;&ensp;&ensp;一路就开始折腾，那是一路曲折啊，重不会到会也不知道自己经历了什么，到现在vue3.x马上又有开始了所以自己也是先试试水，玩了一波相关的语法。&ensp;&ensp;&ensp;&ensp; 废话不多说直接上代码记录下(由于本人没有用到TS所以都是进行与ES6进行) 开始 在vue-cli3.0下安装 composition-api 123npm install @vue/composition-api --save# ORyarn add @vue/composition-api 在使用任何 @vue/composition-api 提供的能力前，必须先通过 Vue.use() 进行安装 1234import Vue from 'vue'import VueCompositionApi from '@vue/composition-api'Vue.use(VueCompositionApi) 安装完成后就可项目中使用相关composition-api来开发了 setup（入口函数）&ensp;&ensp;&ensp;&ensp;setup()函数是vue3中，专门为组件提供的新属性，感觉就跟是跟vue2.x中的data一样需要返回一个Object中包含了自己定义的function, computed, watch以及属性和生命周期。 setup 函数会在 beforeCreate 之后、created 之前执行。 1234setup(props, context) &#123; const state = reactive(&#123;count: 0&#125;) // 创建数据 return state // 返回页面中使用&#125; 接收props数据 在props中定义当前组件允许外界传递过来的参数名称： 123 props: &#123; name: String&#125; 通过setup函数的第一个形参，接收 props 数据： 123setup(props) &#123; console.log(props.name)&#125; context形参 setup函数的第二个形参是一个上下文对象，就是vue2.x中的this，在vue 3.x中，它们的访问方式如下 12345 setup(props, context) &#123; context.slots context.emit context.refs&#125; reactive与ref（响应式数据源） reactive()函数接收一个普通的对象，返回一个响应的数据对象。 这等价于vue2.x中的Vue.observable()函数，vue3.x然后就是可以直接用reactive()函数直接创建响应的数据对象。 按需导入reactive相关函数 import { reactive } from &#39;@vue/composition-api&#39; 在setup()的函数中调用reactive()函数，创建对应的响应式数据对象 12345setup() &#123; // 这个类似于vue2中的data()返回的响应式对象 const state = reactive(&#123; count: 0 &#125;) return state&#125; 在template中访问响应式数据 123&lt;template&gt; &lt;span&gt;当前的count值为:&#123;&#123;count&#125;&#125;&lt;/span&gt;&lt;/template&gt; ref()函数用来根据给定值创建一个响应式的数据对象，ref()函数的调用返回值是一个对象，这个对象上只包含一个value属性。 导入相关ref相关函数 import { ref } from &#39;@vue/composition-api&#39; 创建响应式对象 1234567setup() &#123; const count = ref(0) return &#123; count, name: ref('vue') &#125;&#125; 在template中访问响应式数据123&lt;template&gt; &lt;span&gt;&#123;&#123;count&#125;&#125;--- &#123;&#123;name&#125;&#125;&lt;/span&gt;&lt;/template&gt; isRef的使用 ，isRef()函数主要用来判断某个值是否为ref()创建出来的对象；应用场景：当需要展开某个可能为ref()创建出来的值得时候，例如： 123import &#123; isRef &#125; from '@vue/composition-api'const fooData = isRef(foo) ? foo.value : foo toRefs的使用，toRefs()函数可以将reactive()创建出来的响应式对象，转为普通对象，只不过这个对象上的属性节点都是以ref()类型的像是数据， 最常见应用场景 12345678910111213141516171819202122import &#123; toRefs, reactive &#125; from '@vue/composition-api'setup() &#123; // 定义响应式数据对象 const state = reactive(&#123; count: 0 &#125;) // 定义页面上可用的事件处理函数 const increment = () =&gt; &#123; state.count++ &#125; // 在 setup 中返回一个对象供页面使用 // 这个对象中可以包含响应式的数据，也可以包含事件处理函数 return &#123; // 将 state 上的每个属性，都转化为 ref 形式的响应式数据 ...toRefs(state), // 自增的事件处理函数 increment &#125;&#125; 在template中就直接可以使用count属性和相对应的increment方法了，如果没有使用roRefs直接返回state那么就得通过state.xx来访问数据 123456&lt;template&gt; &lt;div&gt; &lt;span&gt;当前的count值为：&#123;&#123;count&#125;&#125;&lt;/span&gt; &lt;button @click=\"increment\"&gt;add&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; computed与watch（计算属性与监听） computed() 用来创建计算属性，computed() 函数的返回值是一个 ref 的实例。使用 computed 之前需要按需导入： 1import &#123; computed &#125; from '@vue/composition-api' 创建只读的计算属性，在调用computed()函数的时候，传入一个function函数，可以得到一个只读的计算属性。 123456789// 创建一个响应式数据const count = ref(1) // 根据count的值创建一个响应式的计算属性， 它会根据ref自动计算并且返回一个新的refconst computedCount = computed(() =&gt; count.value + 1 ) console.log(computedCount.value) // 打印 2computedCount.value++ //报错 创建可读可写的计算属性 在调用computed()函数的时候传入一个包含get和set的对象，就可以得到一个可读可写的计算属性了。 123456789101112// 创建一个响应式数据const count = ref(1) // 根据count的值创建一个响应式的计算属性， 它会根据ref自动计算并且返回一个新的refconst computedCount = computed(&#123; get: () =&gt; count.value + 1, set: (val) =&gt; count.value = val - 1&#125; ) computedCount.count = 6console.log(count.value) // 打印 5 2.watch() 函数用来监听数据的变化，跟vue2.x中的是一样的不过在这得像computed的使用方法一样导入相关api方法 使用前导入 import { watch } from &#39;@vue/composition-api&#39; 基本用法 1234567891011const count = ref(0)// 定义watch只要count的值变化，就会触发watch的回调// watch 会在创建的时候自动调用一次watch(() =&gt; console.log(count.value))setTimeout(() =&gt; &#123; count.value++&#125;, 1000) 监听指定数据 12345678910111213/ 定义reactive数据源const state = reactive(&#123; count: 0 &#125;)// 监视 state.count 这个数据节点的变化watch(() =&gt; state.count, (now, prev) =&gt; &#123; console.log(now, prev)&#125;)/ 定义ref数据源const count = ref(0)// 监视count这个数据的变化watch(count, (now, prev) =&gt; &#123; console.log(now, prev)&#125;) LifeCycle Hooks(生命周期)在新版中的生命周期需要按需导入，并且只能写setup()函数中。 使用onBeforeMount, onMounted, updated相关生命周期，使用前导入相关api方法 1import &#123; onBeforeMount, onMounted, updated &#125; from '@vue/composition-api' 1234567891011setup () &#123; onBeforeMount(() =&gt; &#123; console.log('onBeforeMount!') &#125;) onMounted(() =&gt; &#123; console.log('onMounted!') &#125;) updated(() =&gt; &#123; console.log('updated!') &#125;) &#125; 相关每个生命周期方法都是传入一个function函数。 vue2.x与新版Composition API之间的映射关系 beforeCreate -&gt; setup created -&gt; setup beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy -&gt; onBeforeUnmount destroyed -&gt; onUnmounted errorCaptured -&gt; onErrorCaptured provide &amp; inject（数据共享）provide()和 inject()可以实现嵌套组件之间的数据传递。这个两个函数只能在setup()函数中使用。父级组件中使用provide()函数可以使数据向下传递，子组件中使用inject()接收上层传过来的数据。 实现代码: 根组件（父组件）parent.vue 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;child-one&gt;&lt;/child-one&gt; &lt;child-two&gt;&lt;/child-two&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; provide &#125; from '@vue/composition-api' import ChildOne from '@/components/Child' import ChildTwo from '@/components/Child' export default &#123; components: &#123; ChildOne, ChildTwo &#125;, setup() &#123; // provide('要共享的数据名称', 被共享的数据) provide('globalName', 'vue') &#125; &#125;&lt;/script&gt; 子组件1 ChildOne.vue 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;!--页面展示数据globalName --&gt; &#123;&#123;globalName&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; inject &#125; from '@vue/composition-api' export default &#123; name: 'ChildOne', setup() &#123; const globalName = inject('globalName') 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 return &#123; globalName &#125; &#125; &#125;&lt;/script&gt; 子组件2 ChildTwo.vue 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;!--页面展示数据globalName --&gt; &#123;&#123;globalName&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; inject &#125; from '@vue/composition-api' export default &#123; name: 'ChildTwo', setup() &#123; const globalName = inject('globalName') 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 return &#123; globalName &#125; &#125; &#125;&lt;/script&gt; provide函数被共享的数据可以使ref和reactive定义的响应式数据，用法类似 template refs（元素组件）我们知道在vue2.x中获取页面元素的DOM可以通过ref写在页面元素上然后在js中通过$refs.x来拿取当前元素的DOM元素信息，操作DOM,在composition-api中我们通过提供的ref方法传入一个null并且定义与页面元素上ref相对应。 代码实现： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;h1 ref=\"h1Ref\"&gt;Hello Word&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, onMounted &#125; from '@vue/composition-api'export default &#123; setup() &#123; // 创建一个 DOM 引用 const h1Ref = ref(null) // 在 DOM 首次加载完毕之后，才能获取到元素的引用 onMounted(() =&gt; &#123; // 为 dom 元素设置字体颜色 // h1Ref.value 是原生DOM对象 console.log(h1Ref.value) &#125;) // 把创建的引用 return 出去 return &#123; h1Ref &#125; &#125;&#125;&lt;/script&gt; 结尾&ensp;&ensp;&ensp;&ensp;感觉composition-api都是以导入的形式使用，感觉没有直接vue2.x中直接使用的方便哈😂。虽然都是说按需引入，使用想用的方法。对比了与vue2.x的各种写法感觉突然转过来有很大不适应，写的各种数据方法都要在setup的入口函数中导出才能在页面上使用。虽然vue2.x定义的数据也需要通过data函数返回值然后在页面中使用，但是方法不用啊，什么计算属性监听也都是不用的啊。可能是自己适应了vue2.x的各种写法，感觉用起来各种爽。转变到vue3.x也就是现在的composition-api还需要点时间。 最后自己还是有个问题没有解决有大佬给我思路吗？就是子父组件的通信怎么写？之前版本是通过$emit进行，我发现这setup函数中写了父组件拿不到。 最后贴上composition-api官方文档 https://vue-composition-api-rfc.netlify.com","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Web前端/Vue","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://jetbn.github.io/tags/Vue/"}]},{"title":"Shopify插件开发入坑体验","slug":"Shopify插件开发入坑体验","date":"2020-04-29T02:58:15.000Z","updated":"2020-04-30T02:39:34.782Z","comments":true,"path":"2020/04/29/Shopify插件开发入坑体验/","link":"","permalink":"http://jetbn.github.io/2020/04/29/Shopify%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E5%9D%91%E4%BD%93%E9%AA%8C/","excerpt":"","text":"前言&ensp;&ensp;&ensp;&ensp;由于公司的需求开发Shopify的应用插件自己特地记录下。简单的介绍下Shopify,它是由托比亚斯·卢克创办的加拿大电子商务软件开发商，总部位于加拿大首都渥太华，其提供的服务软件Shopify是一个SaaS领域的购物车系统，适合跨境电商建立独立站，用户支付一定费用即可在其上利用各种主题/模板建立自己的网上商店。 &ensp;&ensp;&ensp;&ensp;由于是国外的官网文档也都是英文，看起来有点吃力哦（小生英文水平有限🤣🤣）。不过之后应该有中文了现在很多页面有中文了已经。 &ensp;&ensp;&ensp;&ensp;该应该用插件官方推荐是用React的next.js服务端渲染框架以及node.js作为后端语言使用GraphQL开发。作为没接触过GraphQL的我赶紧补了一波知识。后来我一路跌跌撞撞终于现在是了解了一个大概。最终我还是使用node作为主入口程序，验证应用插件获取相关的access_token和商店地址。剩下的请求什么Shopify接口也没有用GraphQL而是使用了ResfulApi让后端工作人员去操作了，然后我请求后端接口进行一系列操作。（最后熟悉了，什么验证都是丢给后端操作了，前端我也就可以使用各种框架了而不是单单只能使用next.js）。 注册获取开发前提要素 创建Shopify开发者账号如图在https://developers.shopify.com/网站注册相关的账号。 在相关partners的页面创建商店(以供后面开发应用使用)以及应用 在创建应用的有自定义应用和公共应用如图： 一般我相信我我们都是创建的公共应用，到目前我开发的应用也都是公共类型，在创建应用的时候URL和相关的重定向URL都是必须写的因为我也没有注册域名啥的吧，所以此时是用了ngrok内网穿透，在官方的开发介绍中也是使用这个。在此我们填写的URL就要和你使用ngrok暴露出去的地址对应了，不过使用node的koa框架有个专门的中间件也是官方使用的重定向地址都是域名后加上了shopify/auth 例如： URL:https://30aca829.ngrok.io, 重定向URL:https://30aca829.ngrok.io/shopify/auth/（电脑重启重新暴露出去这个连个地址都是要重新填一遍，然后koa的中间件就会跳转到https://30aca829.ngrok.io/shopify/auth/进行相关的验证操作。（这在后面的入口）。序中会上代码，然后在后期我们没有用koa作为入口这个地址也是可以自己想怎么填就怎么填）。 创建完成（拿取相关的密钥很重要！！很重要！！作为开发读取数据和请求官方api使用） 差不多了前提就这些步骤，注册成功之后填写好接下来就是一系列代码操作了。 编写开发环境程序 创建项目目录（sample-app），并使用npm初始化项目目录 1npm init -y 安装相关依赖 1npm install --save react react-dom next 因为是用next.js所以不熟悉的还得看看官方文档 https://nextjs.frontendx.cn/ 创建文件pages并在下面新建index.js 1234567const Index &#x3D; () &#x3D;&gt; ( &lt;div&gt; &lt;p&gt;Sample app using React and Next.js&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;);export default Index; 添加相关运行命令打开package.json文件添加 1234567891011&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot; &#125;&#125;&#96;&#96;&#96; 运行开发环境 npm run dev 123 到这里应该是创建一个&#96;next.js&#96;项目然后接下来对接到&#96;Shopify&#96;4. 使用&#96;ngrok&#96;暴露出去自己的&#96;3000&#96;端口因为&#96;next.js&#96;启动的默认是&#96;3000&#96;端口 ngrok http 3000 12345 ![](https:&#x2F;&#x2F;user-gold-cdn.xitu.io&#x2F;2020&#x2F;1&#x2F;17&#x2F;16fb29415dbff038?w&#x3D;976&amp;h&#x3D;519&amp;f&#x3D;png&amp;s&#x3D;30962) 然后在自己创建的应用中设置中添加&#96;对应的url&#96;（得用&#96;https&#96;的）就在上面所说的填写&#96;url&#96; 5. 使用&#96;node&#96;的 &#96;koa&#96;来进行渲染页面操作 1. 创建&#96;env&#96;环境变量文件并写入在上面创建的应用的&#96;KEY&#96; SHOPIFY_API_KEY=&apos;YOUR API KEY FROM SHOPIFY PARTNERS DASHBOARD&apos; SHOPIFY_API_SECRET_KEY=&apos;YOUR API SECRET KEY FROM SHOPIFY PARTNERS DASHBOARD&apos; 12. 安装相关&#96;Shopify&#96;的验证&#96;koa&#96;中间件 npm install --save koa @shopify/koa-shopify-auth dotenv koa-session isomorphic-fetch 13. 创建&#96;server.js&#96;写入相关验证代码 require(&apos;isomorphic-fetch&apos;); const dotenv = require(&apos;dotenv&apos;); const Koa = require(&apos;koa&apos;); const next = require(&apos;next&apos;); const { default: createShopifyAuth } = require(&apos;@shopify/koa-shopify-auth&apos;); const { verifyRequest } = require(&apos;@shopify/koa-shopify-auth&apos;); const session = require(&apos;koa-session&apos;); dotenv.config(); // graphql的相关中间件 const { default: graphQLProxy } = require(&apos;@shopify/koa-shopify-graphql-proxy&apos;); const { ApiVersion } = require(&apos;@shopify/koa-shopify-graphql-proxy&apos;); const port = parseInt(process.env.PORT, 10) || 3000; const dev = process.env.NODE_ENV !== &apos;production&apos;; const app = next({ dev }); const handle = app.getRequestHandler(); const { SHOPIFY_API_SECRET_KEY, SHOPIFY_API_KEY } = process.env; // 环境变量里读取 api-key与api-secret-key app.prepare().then(() =&gt; { const server = new Koa(); server.use(session(server)); server.keys = [SHOPIFY_API_SECRET_KEY]; server.use( createShopifyAuth({ apiKey: SHOPIFY_API_KEY, secret: SHOPIFY_API_SECRET_KEY, scopes: [&apos;read_products&apos;, &apos;write_products&apos;], //填写相关应用api相关请求的权限 afterAuth(ctx) { const { shop, accessToken } = ctx.session; // 通过session拿取相关商店地址以及请求api需要的accessToken ctx.cookies.set(&apos;shopOrigin&apos;, shop, { httpOnly: false }); ctx.redirect(&apos;/&apos;); // 重定向到index首页 }, }), ); server.use(verifyRequest()); server.use(async (ctx) =&gt; { await handle(ctx.req, ctx.res); ctx.respond = false; ctx.res.statusCode = 200; return }); server.use(graphQLProxy({version: ApiVersion.October19})) // 这里填写相关api的版本 server.listen(port, () =&gt; { console.log(`&gt; Ready on http://localhost:${port}`); // 监听端口 }); }); 14. 修改&#96;package.json&#96;文件使用我们的&#96;server.js&#96;来启动项目 { &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;node server.js&quot;, &quot;start&quot;: &quot;NODE_ENV=production node server.js&quot;, &quot;build&quot;: &quot;next build&quot;, } } 1234现在我们启动项目并且用&#96;ngrok&#96;暴露出去的域名就能看到![](https:&#x2F;&#x2F;user-gold-cdn.xitu.io&#x2F;2020&#x2F;1&#x2F;17&#x2F;16fb2a914762cace?w&#x3D;434&amp;h&#x3D;214&amp;f&#x3D;png&amp;s&#x3D;6256)这里还要在域名的&#96;shop&#96;填写我们的商店地址例如我自己的： https://e44132cd.ngrok.io/auth/inline?shop=jetbn.myshopify.com 1234567891011 一切填写就绪之后一&#96;enter&#96;页面就自动跳转了。 最后展示的页面： ![](https:&#x2F;&#x2F;user-gold-cdn.xitu.io&#x2F;2020&#x2F;1&#x2F;17&#x2F;16fb2af2f6b051c0?w&#x3D;1317&amp;h&#x3D;551&amp;f&#x3D;png&amp;s&#x3D;32089)## 折腾其他框架尝试&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;前前后后都是使用&#96;React&#96;的&#96;next.js&#96;开发了两三个应用，感觉就是开发的时候太麻烦了，总要内网穿透，而且展示的页面都是&#96;Shopify&#96;的的自己平台上，而且开发写完代码等它响应过来还很慢。就这原因我又开始折腾了寻求其他的方案看看有没有能在自己开发完了再到它那上面，而且让验证&#96;Shopify&#96;的一系列操作让我们的后端小哥来操作。最终我前端选择&#96;Vue&#96;并且验证都放后端了，这样我就能像平常开发&#96;Vue&#96;项一样了。下面介绍下我纯前端进行&#96; Shopify&#96;的验证操作使用&#96;vue&#96;。（前提要素内网穿透，不过开发的时候不需要）1. 添加安装应用路由 { path: &apos;/shopify/install&apos;, beforeEnter(to, _from, next) { if (to.query.shop) { //要在域名后添加开发的商店地址 const shop = to.query.shop, scopes = &apos;read_orders,read_products,write_products&apos;, // api权限 // 重定向地址就是在创建应用的时候填写的第二个（重定向URL可以自己随意写了），我这里是域名加/shopify/auth redirect_uri = &apos;https://&apos; + process.env.VUE_APP_ROOT_URL + &apos;/shopify/auth&apos;, // 拼接安装应用地址需要SHOPIFY_API_KEY我填写在我的.env文件中了 install_url = &apos;http://&apos; + shop + &apos;/admin/oauth/authorize?client_id=&apos; + process.env.VUE_APP_SHOPIFY_API_KEY + &apos;&amp;scope=&apos; + scopes + &apos;&amp;redirect_uri=&apos; + redirect_uri // 本地跳转安装地址 window.location = install_url } else { next({ path: &apos;/error&apos; }) } } }, 12 2. 重定向验证路由 { path: &apos;/shopify/auth&apos;, beforeEnter(to, _from, next) { // 通过回调的url获取相关的参数 const shop = to.query.shop, hmac = to.query.hmac, code = to.query.code // 使用SHOPIFY_API_SECRET_KEY验证 并且之后拿取access_token（这步没写） if (shop &amp;&amp; hmac &amp;&amp; code) { const map = Object.assign({}, to.query) delete map[&apos;signature&apos;] delete map[&apos;hmac&apos;] const message = querystring.stringify(map) const encrypted = crypto.createHmac(&apos;sha256&apos;, process.env.VUE_APP_SHOPIFY_API_SECRET_KEY) .update(message) .digest(&apos;hex&apos;) // const providedHmac = Buffer.from(hmac, &apos;utf-8&apos;) // const generatedHash = Buffer.from(encrypted, &apos;utf-8&apos;) let hashEquals = false try { // later: Auth fails with `crypto.timingSafeEqual` // hashEquals = crypto.timingSafeEqual(generatedHash, providedHmac) hashEquals = hmac === encrypted } catch (e) { hashEquals = false } if (!hashEquals) { next({ path: &apos;/error&apos; }) } else { next(&apos;/&apos;) } } else { next({ path: &apos;/error&apos; }) } } } `Vue`这相关的验证方案也是从`Github`上面捞的，特地记录下。具体地址忘了，有需要自己可以搜搜。🤣 总结&ensp;&ensp;&ensp;&ensp;经过一段时间的熟悉，自己也算又掌握一项新东西了。刚开始这个Shopify插件应用开发真的是巨坑啊，虽然官方有文档流程，但是都是英文的而且基础的搭建都是api都是用GraphQL然后我自己尝试了都是各种超时操作，请求不到最后就自己弃用了，用ResfulApi。然后就是遇到问题啊啥的都跟本搜不到，我想着这也太难了我，然后只能硬着头皮去官方文档里找，最后到现在也算是起起伏伏终于都熟悉了，搞懂了。 &ensp;&ensp;&ensp;&ensp; 这之后发现了英文水平太重要了。虽然开发文档基本内容能看懂，但是都是半猜半疑的，然后翻译一波。（各种不准确），然后开始补英文吧。🤞 &ensp;&ensp;&ensp;&ensp; 最后放上几个Shopify开发常用的官方文档地址： &ensp;&ensp;&ensp;&ensp;Shopify Partners(创建应用查看应用): https://vue-composition-api-rfc.netlify.com &ensp;&ensp;&ensp;&ensp;Shopify Developers(官方开发文档): https://developers.shopify.com（搭建参考文档） &ensp;&ensp;&ensp;&ensp;Shopify Polaris(官方UI框架): https://developers.shopify.com","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"Web前端/React","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"Shopify","slug":"Shopify","permalink":"http://jetbn.github.io/tags/Shopify/"},{"name":"React","slug":"React","permalink":"http://jetbn.github.io/tags/React/"},{"name":"Next.js","slug":"Next-js","permalink":"http://jetbn.github.io/tags/Next-js/"}]},{"title":"mpvue入坑记录","slug":"mpvue入坑记录","date":"2020-04-29T02:57:09.000Z","updated":"2020-04-30T02:39:23.172Z","comments":true,"path":"2020/04/29/mpvue入坑记录/","link":"","permalink":"http://jetbn.github.io/2020/04/29/mpvue%E5%85%A5%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"使用MpVue开发小程序记录&#160; &#160; &#160; &#160; 当下轻应用，遍布各大互联网公司。像百度、支付宝、微信、字节都是有自己的小程序形式，就现在QQ也推出了小程序的形式，像这种轻应用又不需要安装，就能打开，而且也类似了app形式。当然相对于形式也不能说不会开发吧，该学的还是得学。所以现在也有很多基于框架延伸而出的打包生成多个平台的小程序，例如 基于react的taro、还有wepy、mpvue目前应该这个三个最火热了，然后我尝试了mpvue开发了过程不说坑还是有的。自己也是一步步解决，所以决定记录一下。 首先就搭建了项目使用相关环境自己也是全部尝试了一遍安装了scss环境以及vuex，好像有解决的vue-router自己没有尝试. 1.1 首先讲下scss的mixin我在全局的时候引入在页面页面中能用，为什么在组件中用不了这是啥我也不是清楚。还有就是我在scss中使用font字体的问题，在此中我通过本地的方式引入发现就是加载不了，后来寻找方案在交流群中得知是得将文件放在static文件下并且使用绝对路径的方式引用，是有效不报错了。但是小程序打包又上传了不了，后来我就直接干脆放服务器上了，再通过引用，这下总没问题了。 1.2 再次就是vuex在main.js中引用在vue的原型上加而不是像vue-cli中使用一样 直接写在new VUE中。 在main.js中定义 12345678910import Vue from &#39;vue&#39;import App from &#39;.&#x2F;App&#39;import store from &#39;.&#x2F;store&#39;Vue.config.productionTip &#x3D; falseApp.mpType &#x3D; &#39;app&#39;Vue.prototype.$store &#x3D; storeconst app &#x3D; new Vue(App)app.$mount() 在页面中使用 1this.$store.state 也可以使用vuex的mapState引用某个state 12345678&#x2F;&#x2F; 头部导入import &#123; mapState &#125; from &#39;vuex&#39;&#x2F;&#x2F; 在计算属性中...mapState([ &#39;carBrandCityPrev&#39; &#x2F;&#x2F; 对应stae中定义的]), 自定义TabBar自己刚开始使用也是一头水雾，微信小程序更新的很快。我之前写的一个小程序用的是原生开发的时候，那时候还没有什么定义TabBar啊、导航栏、组件啊什么的。后来我也是看了下官方的demo以及github中mpuve项目的issue中找解决方案，最终还是直接上手搞了一波。中途也是坎坎坷坷。 贴个自定义tabbar地址: https://github.com/jetBn/mpvue-custom-tab-bar 小程序中获取地理位置授权问题，只有在第一次进入的会提示是否授权如果拒绝了授权第二进入都不会授权，都会走授权位置的fail方法,所以这个原因问题。我们只能是通过微信的获取用户的当前设置检查 wx.getSettingapi去检查当前是否授权，通过此方法放在fail方法中检测当前是否开启授权地理位置，如果没有重新调用地理位置授权的方法。 相关检查是否授权方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;&#x2F; fn指相关重新授权的方法 export function checkGetLocationPermison (fn) &#123; wx.getSetting(&#123; success: (res) &#x3D;&gt; &#123; const status &#x3D; res.authSetting if (!status[&#39;scope.userLocation&#39;]) &#123; wx.showModal(&#123; title: &#39;是否授权当前位置&#39;, content: &#39;需要获取您的地理位置，请确认授权，否则地图功能将无法使用获取不了优惠券信息&#39;, success: (subRes) &#x3D;&gt; &#123; if (subRes.confirm) &#123; wx.openSetting(&#123; success: (subRes) &#x3D;&gt; &#123; if (subRes.authSetting[&#39;scope.userLocation&#39;] &#x3D;&#x3D;&#x3D; true) &#123; wx.showToast(&#123; title: &#39;授权成功&#39;, icon: &#39;success&#39;, duration: 1000 &#125;) fn() &#125; else &#123; wx.showToast(&#123; title: &#39;授权失败&#39;, icon: &#39;success&#39;, duration: 1000 &#125;) &#125; &#125; &#125;) &#125; &#125; &#125;) &#125; &#125;, fail: () &#x3D;&gt; &#123; wx.showToast(&#123; title: &#39;调用授权窗口失败&#39;, icon: &#39;success&#39;, duration: 1000 &#125;) &#125; &#125;) &#125; 在mpvue是axios全局处理请求返回值以及请求头设置等等。在npm i axios qs后新建request.js文件，引入qs处理axios中post请求，然后微信小程序中是使用wx.request发送请求的并不是直接使用axios就可以的，所以使用axios的adapter 属性进行我们的请求操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#x2F;&#x2F; 创建axios实例const Axios &#x3D; axios.create(&#123; baseURL: &#39;&#39;, &#x2F;&#x2F; 设置请求域名地址 timeout: 1000 * 60 * 10, &#x2F;&#x2F; 设置请求超时时间 responseType: &#39;json&#39; &#x2F;&#x2F; 设置返回值类型&#125;)&#x2F;&#x2F; 然后使用Axios实例的adapter进行封装微信请求Axios.defaults.adapter &#x3D; (config) &#x3D;&gt; &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; let data &#x3D; config.method &#x3D;&#x3D;&#x3D; &#39;get&#39; ? config.params : qs.stringify(config.params) wx.request(&#123; url: config.url, method: config.method, header: &#123;&#39;Content-type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;&#125;, data, success: (res) &#x3D;&gt; (resolve(res)), fail: (err) &#x3D;&gt; (reject(err)) &#125;) &#125;)&#125;&#x2F;&#x2F; 请求拦截Axios.interceptors.request.use((request) &#x3D;&gt; &#123; return request&#125;, (error) &#x3D;&gt; &#123; return Promise.reject(error)&#125;)&#x2F;&#x2F; 响应拦截Axios.interceptors.response.use((response) &#x3D;&gt; &#123; return response&#125;, (error) &#x3D;&gt; &#123; return Promise.reject(error)&#125;)&#x2F;&#x2F; 导出响应的方法export function fetch (options) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; Axios(options) .then(response &#x3D;&gt; &#123; resolve(response) &#125;) .catch(error &#x3D;&gt; &#123; reject(error) &#125;) &#125;)&#125; 相关自定义头部导航栏根据相关设备判断设置高度，相关计算是顶部状态栏的高度加上相关定义的高度。 12345678910111213141516&#x2F;&#x2F;微信获取相关设备信息的APIwx.getSystemInfo(&#123; success (system) &#123; &#x2F;&#x2F; console.log(&#96;system:&#96;, system) self.statusBarHeight &#x3D; system.statusBarHeight self.platform &#x3D; system.platform const windowHeight &#x3D; system.windowHeight let platformReg &#x3D; &#x2F;ios&#x2F;i if (platformReg.test(system.platform)) &#123; self.titleBarHeight &#x3D; 44 &#x2F;&#x2F; iso的高度 &#125; else &#123; self.titleBarHeight &#x3D; 48 &#x2F;&#x2F;android 的高度 &#125; self.navBarHeight &#x3D; self.statusBarHeight + self.titleBarHeight &#125;&#125;) mpvue中使用组件式封装 然后是内容使用插槽形式，在使用组件的使用插槽内的内容数据更新页面不会实时更新 。（父组件插槽内容块中使用的也是组件封装的组件）（问题1）。然后我使用了 不封装组件 直接写页面样式点击组件的事件会触发插槽中的事件？？？（问题2） 事件跟插槽中的事件不在同一个div中。最后就是不用插槽才解决了上述问题1，2 npm run dev 会卡在node build/dev-server.js wx 最后我自己也是在官方的github仓库中的issu中找到解决方案在build文件夹的build.js中require(&#39;./check-versions&#39;)()注释掉然后也就能正常运行了。具体的好像是在经过check-versions函数的时候执行特别的慢。 &#160; &#160; &#160; &#160;最后总结下MpVue这个相对于vue针对于小程序的框架，大部分都是使用vue相关语法所以对于熟悉vue的来说还是很容易上手的。开发效率也还可以。感觉会使用vue再次熟悉微信小程序官方的API开发效率还是很高的，不过还是有挺多坑的，我这边坑可能是没有遇到很多。很幸运，具体的相关的语法情况可以对应官方网站的介绍情况。 &#160; &#160; &#160; &#160;最后附上相关网站地址： &#160; &#160; &#160; &#160;官方网站：http://mpvue.com &#160; &#160; &#160; &#160;github相关仓库地址： https://github.com/Meituan-Dianping/mpvue","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Web前端/Vue","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/Vue/"},{"name":"小程序","slug":"Web前端/Vue/小程序","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/Vue/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://jetbn.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]}],"categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Web前端/Vue","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/Vue/"},{"name":"React","slug":"Web前端/React","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/React/"},{"name":"小程序","slug":"Web前端/Vue/小程序","permalink":"http://jetbn.github.io/categories/Web%E5%89%8D%E7%AB%AF/Vue/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jetbn.github.io/tags/CSS/"},{"name":"Vue","slug":"Vue","permalink":"http://jetbn.github.io/tags/Vue/"},{"name":"Shopify","slug":"Shopify","permalink":"http://jetbn.github.io/tags/Shopify/"},{"name":"React","slug":"React","permalink":"http://jetbn.github.io/tags/React/"},{"name":"Next.js","slug":"Next-js","permalink":"http://jetbn.github.io/tags/Next-js/"},{"name":"小程序","slug":"小程序","permalink":"http://jetbn.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]}