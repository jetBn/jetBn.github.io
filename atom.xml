<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jetbn.github.io/"/>
  <updated>2020-04-30T07:22:17.122Z</updated>
  <id>http://jetbn.github.io/</id>
  
  <author>
    <name>jetBn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你不知道的CSS </title>
    <link href="http://jetbn.github.io/2020/04/30/%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84CSS/"/>
    <id>http://jetbn.github.io/2020/04/30/%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84CSS/</id>
    <published>2020-04-30T05:42:00.000Z</published>
    <updated>2020-04-30T07:22:17.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>&ensp;&ensp;&ensp;&ensp;<code>CSS</code>的世界是神奇的。当今所以不管移动端还是PC端网页都是离不开<code>CSC</code>（层叠样式表），像类选择，id选择等等这些选择器 我们工作都有用到，但是难免忽略一些，<code>CSS</code>中更强大的属性我们很少用到，特此记录一些。</p><h2 id="用-兄弟选择器来美化表单元素"><a href="#用-兄弟选择器来美化表单元素" class="headerlink" title="用~/ +兄弟选择器来美化表单元素"></a>用<code>~</code>/ <code>+</code>兄弟选择器来美化表单元素</h2><ol><li><code>~</code>选择器：查找某一个元素的后面的所有兄弟元素</li><li><code>+</code>选择器：查找某一个元素的后面紧邻的兄弟元素</li></ol><h2 id="用font-size：0来清除间距"><a href="#用font-size：0来清除间距" class="headerlink" title="用font-size：0来清除间距"></a>用<code>font-size：0</code>来清除间距</h2><p> &ensp;&ensp;&ensp;&ensp;<code>inline-block</code>的元素之间会受空白区域的影响，也就是元素之间差不多会有一个字符的间隙。如果在同一行内有4个25%相同宽度的元素，会导致最后一个元素掉下来（如图）。你可以利用元素浮动<code>float</code>，或者压缩html，清除元素间的空格来解决。但最简单有效的方法还是设置父元素的<code>font-size</code>属性为0。</p><h2 id="用-overflow-來清除浮动-创建块级格式化上下文"><a href="#用-overflow-來清除浮动-创建块级格式化上下文" class="headerlink" title="用 overflow 來清除浮动(创建块级格式化上下文)"></a>用 overflow 來清除浮动(创建块级格式化上下文)</h2><p> 通过触发BFC方式，实现清除浮动(父元素添加overflow:hidden)<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">.fahter&#123;<br>      width: 400px;<br>      border: 1px solid deeppink;<br>      overflow: hidden;<br>  &#125;<br></code></pre></td></tr></table></figure></p><h2 id="用pointer-event来禁用事件"><a href="#用pointer-event来禁用事件" class="headerlink" title="用pointer-event来禁用事件"></a>用pointer-event来禁用事件</h2><ol><li><p>阻止任何点击动作的执行</p></li><li><p>使链接显示为默认光标(cursor:default)</p></li><li><p>阻止触发hover和active状态</p></li><li><p>阻止JavaScript点击事件的触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;使用该类，任何点击事件将无效<br><br>.disabled &#123; pointer-events: none; &#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="用max-width来防止图片撑破容器"><a href="#用max-width来防止图片撑破容器" class="headerlink" title="用max-width来防止图片撑破容器"></a>用max-width来防止图片撑破容器</h2><p> 针对内容性的文案，图片大小都是未知的，为了防止图片过大而撑破容器，可以通过设置图片的max-width:100%来处理。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">img &#123;<br>   display:inline-block;<br>   max-width: 100%;  <br>   &#125;<br></code></pre></td></tr></table></figure></p><h2 id="实现三角形"><a href="#实现三角形" class="headerlink" title="实现三角形"></a>实现三角形</h2><p> 新建一个元素，将它的宽高都设置为0；然后通过设置border属性来实现三角形效果<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain"> .arrow&#123;<br>    width: 0;<br>    height: 0;<br><br>    &#x2F;*直角三角形*&#x2F;<br><br>    &#x2F;* border-width: 50px 50px 0 0;<br>    border-style: solid;<br>    border-color: transparent #000 transparent transparent; *&#x2F;<br><br>    &#x2F;*向下三角形*&#x2F;<br>    &#x2F;* border-width: 100px 100px 0 100px;<br>    border-style: solid;<br>    border-color: brown transparent transparent transparent; *&#x2F;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="移动端禁止用户长按文字选择功能"><a href="#移动端禁止用户长按文字选择功能" class="headerlink" title="移动端禁止用户长按文字选择功能"></a>移动端禁止用户长按文字选择功能</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain"> .unselect &#123;<br>  -webkit-touch-callout:none;<br>  -webkit-user-select:none;<br>  -khtml-user-select:none;<br>  -moz-user-select:none;<br>  -ms-user-select:none;<br>  user-select:none<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文字模糊"><a href="#文字模糊" class="headerlink" title="文字模糊"></a>文字模糊</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain"> .blur &#123;<br>  color: transparent;<br>  text-shadow: 0 0 5px rgba(0, 0, 0, 0.5)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="超出N行显示省略号"><a href="#超出N行显示省略号" class="headerlink" title="超出N行显示省略号"></a>超出N行显示省略号</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain"> .hide-text-n &#123;<br>  display: -webkit-box;<br>  -webkit-box-orient: vertical;<br>  -webkit-line-clamp: n;<br>  overflow: hidden<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><p> 写transition、animation时，请用transform代替left、top等属性，从而使动画更流畅</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain"> cube &#123;<br>  -webkit-transform: translateZ(0);<br>  -moz-transform: translateZ(0);<br>  -ms-transform: translateZ(0);<br>  -o-transform: translateZ(0);<br>  transform: translateZ(0)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移动端屏幕旋转时，字体大小不改变"><a href="#移动端屏幕旋转时，字体大小不改变" class="headerlink" title="移动端屏幕旋转时，字体大小不改变"></a>移动端屏幕旋转时，字体大小不改变</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain"> html, body, form, p, div, h1, h2, h3, h4, h5, h6 &#123;<br> -webkit-text-size-adjust: 100%;<br> -ms-text-size-adjust: 100%;<br> text-size-adjust: 100%<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="锚点跳转平滑过渡"><a href="#锚点跳转平滑过渡" class="headerlink" title="锚点跳转平滑过渡"></a>锚点跳转平滑过渡</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">body &#123;<br>   scroll-behavior: smooth;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="最后一个元素不需要边框、边距等"><a href="#最后一个元素不需要边框、边距等" class="headerlink" title="最后一个元素不需要边框、边距等"></a>最后一个元素不需要边框、边距等</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">ul &gt; li:not(:last-child) &#123;<br>  border-bottom: 1px solid #c5b7b7<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="清除浮动-适应伪类"><a href="#清除浮动-适应伪类" class="headerlink" title="清除浮动(适应伪类)"></a>清除浮动(适应伪类)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">.clearfix::after &#123;<br>  content: &#39;&#39;;<br>  display: block;<br>  height: 0;<br>  visibility: hidden;<br>  clear: both<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CSS选择器选基数项、偶数项、倍数分组项"><a href="#CSS选择器选基数项、偶数项、倍数分组项" class="headerlink" title="CSS选择器选基数项、偶数项、倍数分组项"></a>CSS选择器选基数项、偶数项、倍数分组项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;* 基数 *&#x2F;<br>.selector:nth-child(2n-1) &#123;&#125;<br><br>&#x2F;* 偶数 *&#x2F;<br>.selector:nth-child(2n) &#123;&#125;<br><br>&#x2F;* 倍数分组项 *&#x2F;<br>.selector:nth-child(3n+1) &#123;&#125; &#x2F;* 匹配第1、4、7、10... *&#x2F;<br>.selector:nth-child(3n+5) &#123;&#125; &#x2F;* 匹配第5、8、11、14... *&#x2F;<br>.selector:nth-child(5n-1) &#123;&#125; &#x2F;* 匹配第4、9、13、17... *&#x2F;<br></code></pre></td></tr></table></figure><h2 id="当输入框的value的长度不为0时，显示搜索按钮"><a href="#当输入框的value的长度不为0时，显示搜索按钮" class="headerlink" title="当输入框的value的长度不为0时，显示搜索按钮"></a>当输入框的value的长度不为0时，显示搜索按钮</h2><p>用到placeholder-shown伪类，简单来说就是当input标签有了placeholder属性并且内容不为空时，会触发该状态，但是当input标签有了value值之后，就会消除该状态，也要配合:not选择器</p><p><code>html</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;div class&#x3D;&quot;input-line&quot;&gt;<br>  &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入关键字进行搜索&quot;&gt;<br>  &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;search-btn&quot;&gt;搜索&lt;&#x2F;button&gt;<br>&lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure><p><code>css</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">.search-btn &#123;<br>  opacity: 0;<br>  transition: all .5s ease-in-out<br>&#125;<br><br> input:not(:placeholder-shown)~.search-btn &#123;<br>  opacity: 1<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&lt;code&gt;CSS&lt;/code&gt;的世界是神奇的。当今所以不管移动端还是PC端网页都
      
    
    </summary>
    
    
      <category term="Web前端" scheme="http://jetBn.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://jetBn.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue3.0尝试</title>
    <link href="http://jetbn.github.io/2020/04/29/Vue3-0%E5%B0%9D%E8%AF%95/"/>
    <id>http://jetbn.github.io/2020/04/29/Vue3-0%E5%B0%9D%E8%AF%95/</id>
    <published>2020-04-29T02:59:17.000Z</published>
    <updated>2020-04-30T02:09:54.002Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9e71255c62bc0?w=299&h=300&f=png&s=43799" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>&ensp;&ensp;&ensp;&ensp;有关vue2的相关相关语法我相信大家都已经的语法我相信大家都已经会了，现在都已经<code>2020</code>年了vue作为前端这么热门的框架, 不去学一波对的自己是做前端的吗？哈哈哈哈🤣🤣🤣。<br/><br>&ensp;&ensp;&ensp;&ensp;一路就开始折腾，那是一路曲折啊，重不会到会也不知道自己经历了什么，到现在<code>vue3.x</code>马上又有开始了所以自己也是先试试水，玩了一波相关的语法。<br/><br>&ensp;&ensp;&ensp;&ensp; 废话不多说直接上代码记录下(由于本人没有用到<code>TS</code>所以都是进行与<code>ES6</code>进行)</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ol><li>在<code>vue-cli3.0</code>下安装 <code>composition-api</code> <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @vue/composition-api --save<br><span class="hljs-comment"># OR</span><br>yarn add @vue/composition-api<br></code></pre></td></tr></table></figure></li><li>在使用任何 <code>@vue/composition-api</code> 提供的能力前，必须先通过 Vue.use() 进行安装 <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><span class="hljs-keyword">import</span> VueCompositionApi <span class="hljs-keyword">from</span> <span class="hljs-string">'@vue/composition-api'</span><br><br>Vue.use(VueCompositionApi)<br></code></pre></td></tr></table></figure> 安装完成后就可项目中使用相关<code>composition-api</code>来开发了</li></ol><h2 id="setup（入口函数）"><a href="#setup（入口函数）" class="headerlink" title="setup（入口函数）"></a>setup（入口函数）</h2><p>&ensp;&ensp;&ensp;&ensp;<code>setup()</code>函数是<code>vue3</code>中，专门为组件提供的新属性，感觉就跟是跟<code>vue2.x</code>中的<code>data</code>一样需要返回一个<code>Object</code>中包含了自己定义的<code>function</code>, <code>computed</code>, <code>watch</code>以及属性和生命周期。</p><ol><li><p>setup 函数会在 beforeCreate 之后、created 之前执行。</p> <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">setup(props, context) &#123;<br>    const <span class="hljs-keyword">state</span> = reactive(&#123;count: <span class="hljs-number">0</span>&#125;) // 创建数据<br>    return <span class="hljs-keyword">state</span> // 返回页面中使用<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接收<code>props</code>数据</p><ol><li>在<code>props</code>中定义当前组件允许外界传递过来的参数名称：  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-tag">props</span>: &#123;<br>    <span class="hljs-attribute">name</span>: String<br>&#125;<br></code></pre></td></tr></table></figure></li><li>通过<code>setup</code>函数的第一个形参，接收 props 数据： <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">setup(<span class="hljs-built_in">props</span>) &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">props</span>.name)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>context形参</p><p> <code>setup</code>函数的第二个形参是一个上下文对象，就是<code>vue2.x</code>中的<code>this</code>，在<code>vue 3.x</code>中，它们的访问方式如下</p> <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"> setup(<span class="hljs-built_in">props</span>, <span class="hljs-built_in">context</span>) &#123;<br>    <span class="hljs-built_in">context</span>.slots<br>    <span class="hljs-built_in">context</span>.emit<br>    <span class="hljs-built_in">context</span>.refs<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="reactive与ref（响应式数据源）"><a href="#reactive与ref（响应式数据源）" class="headerlink" title="reactive与ref（响应式数据源）"></a>reactive与ref（响应式数据源）</h2><ol><li><p><code>reactive()</code>函数接收一个普通的对象，返回一个响应的数据对象。</p><p> 这等价于<code>vue2.x</code>中的<code>Vue.observable()</code>函数，<code>vue3.x</code>然后就是可以直接用reactive()函数直接创建响应的数据对象。</p><ol><li><p>按需导入<code>reactive</code>相关函数</p><p> <code>import { reactive } from &#39;@vue/composition-api&#39;</code></p></li><li><p>在<code>setup()</code>的函数中调用<code>reactive()</code>函数，创建对应的响应式数据对象</p> <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">setup() &#123;<br>    // 这个类似于vue2中的data()返回的响应式对象<br>    const <span class="hljs-keyword">state</span> = reactive(&#123; count: <span class="hljs-number">0</span> &#125;) <br>    return <span class="hljs-keyword">state</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在<code>template</code>中访问响应式数据</p> <figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>当前的count值为:</span><span class="hljs-template-variable">&#123;&#123;count&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol></li><li><p><code>ref()</code>函数用来根据给定值创建一个响应式的数据对象，<code>ref()</code>函数的调用返回值是一个对象，这个对象上只包含一个<code>value</code>属性。</p><ol><li><p>导入相关<code>ref</code>相关函数</p><p> <code>import { ref } from &#39;@vue/composition-api&#39;</code></p></li><li><p>创建响应式对象</p> <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">setup() &#123;<br>    const <span class="hljs-built_in">count</span> = <span class="hljs-keyword">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-built_in">        return</span> &#123;<br>            <span class="hljs-built_in">count</span>,<br>            <span class="hljs-built_in">name</span>: <span class="hljs-keyword">ref</span>('vue')<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>在<code>template</code>中访问响应式数据<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;count&#125;&#125;</span><span class="xml">--- </span><span class="hljs-template-variable">&#123;&#123;name&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p><code>isRef</code>的使用<br> ，<code>isRef()</code>函数主要用来判断某个值是否为<code>ref()</code>创建出来的对象；应用场景：当需要展开某个可能为<code>ref()</code>创建出来的值得时候，例如：</p> <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cs">import &#123; isRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@vue/composition-api'</span><br><br><span class="hljs-keyword">const</span> fooData = isRef(foo) ? foo.<span class="hljs-keyword">value</span> : foo<br></code></pre></td></tr></table></figure></li><li><p><code>toRefs</code>的使用，<code>toRefs()</code>函数可以将<code>reactive()</code>创建出来的响应式对象，转为普通对象，只不过这个对象上的属性节点都是以<code>ref()</code>类型的像是数据， 最常见应用场景</p> <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pf">import &#123; <span class="hljs-keyword">to</span>Refs, reactive &#125; <span class="hljs-keyword">from</span> '@vue/composition-api'<br><br>setup() &#123;<br>    // 定义响应式数据对象<br>    const <span class="hljs-keyword">state</span> = reactive(&#123;<br>      count: <span class="hljs-number">0</span><br>    &#125;)<br>    <br>    // 定义页面上可用的事件处理函数<br>    const increment = () =&gt; &#123;<br>      <span class="hljs-keyword">state</span>.count++<br>    &#125;<br>    <br>    // 在 setup 中返回一个对象供页面使用<br>    // 这个对象中可以包含响应式的数据，也可以包含事件处理函数<br>    return &#123;<br>      // 将 <span class="hljs-keyword">state</span> 上的每个属性，都转化为 ref 形式的响应式数据<br>      ...<span class="hljs-keyword">to</span>Refs(<span class="hljs-keyword">state</span>),<br>      // 自增的事件处理函数<br>      increment<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在<code>template</code>中就直接可以使用<code>count</code>属性和相对应的<code>increment</code>方法了，如果没有使用<code>roRefs</code>直接返回<code>state</code>那么就得通过<code>state.xx</code>来访问数据</p> <figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>当前的count值为：</span><span class="hljs-template-variable">&#123;&#123;count&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"increment"</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="computed与watch（计算属性与监听）"><a href="#computed与watch（计算属性与监听）" class="headerlink" title="computed与watch（计算属性与监听）"></a>computed与watch（计算属性与监听）</h2><ol><li><p><code>computed()</code> 用来创建计算属性，<code>computed()</code> 函数的返回值是一个 ref 的实例。使用 <code>computed</code> 之前需要按需导入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">import</span> &#123; <span class="hljs-attribute">computed</span> &#125; from <span class="hljs-string">'<span class="hljs-variable">@vue</span>/composition-api'</span><br></code></pre></td></tr></table></figure><ol><li><p>创建只读的计算属性，在调用<code>computed()</code>函数的时候，传入一个<code>function</code>函数，可以得到一个只读的计算属性。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// 创建一个响应式数据</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-keyword">ref</span>(<span class="hljs-number">1</span>) <br><br><span class="hljs-comment">// 根据count的值创建一个响应式的计算属性， 它会根据ref自动计算并且返回一个新的ref</span><br><span class="hljs-keyword">const</span> computedCount = computed(() =&gt; count.<span class="hljs-keyword">value</span> + <span class="hljs-number">1</span> ) <br><br>console.log(computedCount.<span class="hljs-keyword">value</span>) <span class="hljs-comment">// 打印 2</span><br><br>computedCount.<span class="hljs-keyword">value</span>++ <span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure></li><li><p>创建可读可写的计算属性</p><p>在调用<code>computed()</code>函数的时候传入一个包含<code>get</code>和<code>set</code>的对象，就可以得到一个可读可写的计算属性了。</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">// 创建一个响应式数据</span><br>const <span class="hljs-built_in">count</span> = ref(<span class="hljs-number">1</span>) <br><br><span class="hljs-comment">// 根据count的值创建一个响应式的计算属性， 它会根据ref自动计算并且返回一个新的ref</span><br>const computedCount = computed(&#123;<br>    <span class="hljs-built_in">get</span>: () =&gt; <span class="hljs-built_in">count</span>.<span class="hljs-built_in">value</span> + <span class="hljs-number">1</span>,<br>    <span class="hljs-built_in">set</span>: (val) =&gt; <span class="hljs-built_in">count</span>.<span class="hljs-built_in">value</span> = val - <span class="hljs-number">1</span><br>&#125; ) <br><br>computedCount.<span class="hljs-built_in">count</span> = <span class="hljs-number">6</span><br><br>console.log(<span class="hljs-built_in">count</span>.<span class="hljs-built_in">value</span>) <span class="hljs-comment">// 打印 5</span><br></code></pre></td></tr></table></figure></li></ol><p>2.<code>watch()</code> 函数用来监听数据的变化，跟<code>vue2.x</code>中的是一样的不过在这得像<code>computed</code>的使用方法一样导入相关<code>api</code>方法</p><p>使用前导入 <code>import { watch } from &#39;@vue/composition-api&#39;</code></p><ol><li><p>基本用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> count = ref(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 定义watch只要count的值变化，就会触发watch的回调</span><br><span class="hljs-comment">// watch 会在创建的时候自动调用一次</span><br><br>watch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(count.value))<br><br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    count.value++<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure></li><li><p>监听指定数据</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pf">/ 定义reactive数据源<br>const <span class="hljs-keyword">state</span> = reactive(&#123; count: <span class="hljs-number">0</span> &#125;)<br>// 监视 <span class="hljs-keyword">state</span>.count 这个数据节点的变化<br>watch(() =&gt; <span class="hljs-keyword">state</span>.count, (now, prev) =&gt; &#123; <br>    console.<span class="hljs-keyword">log</span>(now, prev)<br>&#125;)<br><br>/ 定义ref数据源<br>const count = ref(<span class="hljs-number">0</span>)<br>// 监视count这个数据的变化<br>watch(count, (now, prev) =&gt; &#123; <br>    console.<span class="hljs-keyword">log</span>(now, prev)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="LifeCycle-Hooks-生命周期"><a href="#LifeCycle-Hooks-生命周期" class="headerlink" title="LifeCycle Hooks(生命周期)"></a>LifeCycle Hooks(生命周期)</h2><p>在新版中的生命周期需要按需导入，并且只能写<code>setup()</code>函数中。</p></li></ol></li></ol></li></ol><p>使用<code>onBeforeMount</code>, <code>onMounted</code>, <code>updated</code>相关生命周期，使用前导入相关<code>api</code>方法</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; onBeforeMount, onMounted, updated &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@vue/composition-api'</span><br></code></pre></td></tr></table></figure> <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">setup () &#123;<br>   onBeforeMount(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'onBeforeMount!'</span>)<br>   &#125;)<br>   onMounted(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'onMounted!'</span>)<br>   &#125;)<br>   updated(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'updated!'</span>)<br>   &#125;) <br>&#125;<br></code></pre></td></tr></table></figure><p> 相关每个生命周期方法都是传入一个<code>function</code>函数。</p><p> <code>vue2.x</code>与新版<code>Composition API</code>之间的映射关系</p><ul><li><code>beforeCreate</code> -&gt; <code>setup</code></li><li><code>created</code> -&gt; <code>setup</code></li><li><code>beforeMount</code> -&gt; <code>onBeforeMount</code></li><li><code>mounted</code> -&gt; <code>onMounted</code></li><li><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></li><li><code>updated</code> -&gt; <code>onUpdated</code></li><li><code>beforeDestroy</code> -&gt; <code>onBeforeUnmount</code></li><li><code>destroyed</code> -&gt; <code>onUnmounted</code></li><li><code>errorCaptured</code> -&gt; <code>onErrorCaptured</code></li></ul><h2 id="provide-amp-inject（数据共享）"><a href="#provide-amp-inject（数据共享）" class="headerlink" title="provide &amp; inject（数据共享）"></a>provide &amp; inject（数据共享）</h2><p><code>provide()</code>和 <code>inject()</code>可以实现嵌套组件之间的数据传递。这个两个函数只能在<code>setup()</code>函数中使用。父级组件中使用<code>provide()</code>函数可以使数据向下传递，子组件中使用<code>inject()</code>接收上层传过来的数据。</p><p>实现代码:</p><p>根组件（父组件）<code>parent.vue</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child-one</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-one</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child-two</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-two</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@vue/composition-api'</span></span><br><span class="javascript">  <span class="hljs-keyword">import</span> ChildOne <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/Child'</span></span><br><span class="javascript">  <span class="hljs-keyword">import</span> ChildTwo <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/Child'</span></span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    components: &#123;<br>       ChildOne,<br>       ChildTwo<br>    &#125;,<br>    setup() &#123;<br><span class="actionscript">    <span class="hljs-comment">// provide('要共享的数据名称', 被共享的数据)</span></span><br><span class="actionscript">      provide(<span class="hljs-string">'globalName'</span>, <span class="hljs-string">'vue'</span>) </span><br>    &#125;<br>  &#125;<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件1 <code>ChildOne.vue</code></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--页面展示数据globalName --&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;globalName&#125;&#125;</span><span class="xml"> </span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  import &#123; inject &#125; from '@vue/composition-api'</span><br><span class="xml">  export default &#123;</span><br><span class="xml">    name: 'ChildOne',</span><br><span class="xml">    setup() &#123;</span><br><span class="xml">      const globalName = inject('globalName') 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据</span><br><span class="xml">      return &#123;</span><br><span class="xml">        globalName</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子组件2 <code>ChildTwo.vue</code></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--页面展示数据globalName --&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;globalName&#125;&#125;</span><span class="xml"> </span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  import &#123; inject &#125; from '@vue/composition-api'</span><br><span class="xml">  export default &#123;</span><br><span class="xml">    name: 'ChildTwo',</span><br><span class="xml">    setup() &#123;</span><br><span class="xml">      const globalName = inject('globalName') 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据</span><br><span class="xml">      return &#123;</span><br><span class="xml">        globalName</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>provide</code>函数被共享的数据可以使<code>ref</code>和<code>reactive</code>定义的响应式数据，用法类似</p><h2 id="template-refs（元素组件）"><a href="#template-refs（元素组件）" class="headerlink" title="template refs（元素组件）"></a>template refs（元素组件）</h2><p>我们知道在<code>vue2.x</code>中获取页面元素的<code>DOM</code>可以通过<code>ref</code>写在页面元素上然后在<code>js</code>中通过<code>$refs.x</code>来拿取当前元素的<code>DOM</code>元素信息，操作<code>DOM</code>,在<code>composition-api</code>中我们通过提供的<code>ref</code>方法传入一个<code>null</code>并且定义与页面元素上<code>ref</code>相对应。</p><p>代码实现： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"h1Ref"</span>&gt;</span>Hello Word<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@vue/composition-api'</span></span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  setup() &#123;<br><span class="actionscript">    <span class="hljs-comment">// 创建一个 DOM 引用</span></span><br><span class="actionscript">    <span class="hljs-keyword">const</span> h1Ref = ref(<span class="hljs-literal">null</span>)</span><br><br><span class="actionscript">    <span class="hljs-comment">// 在 DOM 首次加载完毕之后，才能获取到元素的引用</span></span><br><span class="javascript">    onMounted(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="actionscript">      <span class="hljs-comment">// 为 dom 元素设置字体颜色</span></span><br><span class="actionscript">      <span class="hljs-comment">// h1Ref.value 是原生DOM对象</span></span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(h1Ref.value)</span><br>    &#125;)<br><br><span class="actionscript">    <span class="hljs-comment">// 把创建的引用 return 出去</span></span><br><span class="actionscript">    <span class="hljs-keyword">return</span> &#123;</span><br>      h1Ref<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>&ensp;&ensp;&ensp;&ensp;感觉<code>composition-api</code>都是以导入的形式使用，感觉没有直接<code>vue2.x</code>中直接使用的方便哈😂。虽然都是说按需引入，使用想用的方法。对比了与<code>vue2.x</code>的各种写法感觉突然转过来有很大不适应，写的各种数据方法都要在<code>setup</code>的入口函数中导出才能在页面上使用。虽然<code>vue2.x</code>定义的数据也需要通过<code>data</code>函数返回值然后在页面中使用，但是方法不用啊，什么计算属性监听也都是不用的啊。可能是自己适应了<code>vue2.x</code>的各种写法，感觉用起来各种爽。转变到<code>vue3.x</code>也就是现在的<code>composition-api</code>还需要点时间。</p><p>最后自己还是有个问题没有解决有大佬给我思路吗？就是子父组件的通信怎么写？之前版本是通过<code>$emit</code>进行，我发现这<code>setup</code>函数中写了父组件拿不到。</p><p>最后贴上<code>composition-api</code>官方文档</p><p><a href="https://vue-composition-api-rfc.netlify.com" target="_blank" rel="noopener">https://vue-composition-api-rfc.netlify.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/13/16f9e71255c62bc0?w=299&amp;h=300&amp;f=png&amp;s=43799&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class
      
    
    </summary>
    
    
      <category term="Web前端" scheme="http://jetBn.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://jetBn.github.io/categories/Web%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://jetBn.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Shopify插件开发入坑体验</title>
    <link href="http://jetbn.github.io/2020/04/29/Shopify%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E5%9D%91%E4%BD%93%E9%AA%8C/"/>
    <id>http://jetbn.github.io/2020/04/29/Shopify%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E5%9D%91%E4%BD%93%E9%AA%8C/</id>
    <published>2020-04-29T02:58:15.000Z</published>
    <updated>2020-04-30T02:39:34.782Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2020/1/16/16facfbcc2c3ad20?w=500&h=144&f=png&s=18435" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp;&ensp;&ensp;&ensp;由于公司的需求开发<code>Shopify</code>的应用插件自己特地记录下。简单的介绍下<code>Shopify</code>,它是由托比亚斯·卢克创办的加拿大电子商务软件开发商，总部位于加拿大首都渥太华，其提供的服务软件<code>Shopify</code>是一个<code>SaaS</code>领域的购物车系统，适合跨境电商建立独立站，用户支付一定费用即可在其上利用各种主题/模板建立自己的网上商店。</p><p>&ensp;&ensp;&ensp;&ensp;由于是国外的官网文档也都是英文，看起来有点吃力哦（小生英文水平有限🤣🤣）。不过之后应该有中文了现在很多页面有中文了已经。</p><p>&ensp;&ensp;&ensp;&ensp;该应该用插件官方推荐是用<code>React</code>的<code>next.js</code>服务端渲染框架以及<code>node.js</code>作为后端语言使用<code>GraphQL</code>开发。作为没接触过<code>GraphQL</code>的我赶紧补了一波知识。后来我一路跌跌撞撞终于现在是了解了一个大概。最终我还是使用<code>node</code>作为主入口程序，验证应用插件获取相关的<code>access_token</code>和商店地址。剩下的请求什么<code>Shopify</code>接口也没有用<code>GraphQL</code>而是使用了<code>ResfulApi</code>让后端工作人员去操作了，然后我请求后端接口进行一系列操作。（最后熟悉了，什么验证都是丢给后端操作了，前端我也就可以使用各种框架了而不是单单只能使用<code>next.js</code>）。</p><h2 id="注册获取开发前提要素"><a href="#注册获取开发前提要素" class="headerlink" title="注册获取开发前提要素"></a>注册获取开发前提要素</h2><ol><li>创建<code>Shopify</code>开发者账号<br><img src="https://user-gold-cdn.xitu.io/2020/1/16/16fadd29cd892624?w=1477&h=599&f=png&s=141044" alt=""><br>如图在<a href="https://developers.shopify.com/" target="_blank" rel="noopener">https://developers.shopify.com/</a>网站注册相关的账号。</li><li>在相关<code>partners</code>的页面创建商店(以供后面开发应用使用)以及应用<br><img src="https://user-gold-cdn.xitu.io/2020/1/16/16fadd983d275ceb?w=1579&h=744&f=jpeg&s=164230" alt=""><ol><li>在创建应用的有自定义应用和公共应用如图：<br> <img src="https://user-gold-cdn.xitu.io/2020/1/16/16faddc034ed8c10?w=965&h=849&f=png&s=60560" alt=""><br> 一般我相信我我们都是创建的公共应用，到目前我开发的应用也都是公共类型，在创建应用的时候<code>URL</code>和相关的重定向<code>URL</code>都是必须写的因为我也没有注册域名啥的吧，所以此时是用了<code>ngrok</code>内网穿透，在官方的开发介绍中也是使用这个。在此我们填写的<code>URL</code>就要和你使用<code>ngrok</code>暴露出去的地址对应了，不过使用<code>node</code>的<code>koa</code>框架有个专门的中间件也是官方使用的重定向地址都是域名后加上了<code>shopify/auth</code> 例如：  URL:<code>https://30aca829.ngrok.io</code>, 重定向URL:<code>https://30aca829.ngrok.io/shopify/auth/</code>（电脑重启重新暴露出去这个连个地址都是要重新填一遍，然后<code>koa</code>的中间件就会跳转到<code>https://30aca829.ngrok.io/shopify/auth/</code>进行相关的验证操作。（这在后面的入口）。序中会上代码，然后在后期我们没有用<code>koa</code>作为入口这个地址也是可以自己想怎么填就怎么填）。</li><li>创建完成（拿取相关的密钥很重要！！很重要！！作为开发读取数据和请求官方<code>api</code>使用）<br> <img src="https://user-gold-cdn.xitu.io/2020/1/16/16fade6ef2e35432?w=496&h=355&f=png&s=19659" alt=""><br> 差不多了前提就这些步骤，注册成功之后填写好接下来就是一系列代码操作了。</li></ol></li></ol><h2 id="编写开发环境程序"><a href="#编写开发环境程序" class="headerlink" title="编写开发环境程序"></a>编写开发环境程序</h2><ol><li><p>创建项目目录（sample-app），并使用<code>npm</code>初始化项目目录 </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm init -y<br></code></pre></td></tr></table></figure></li><li><p>安装相关依赖</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install --save react react-dom next<br></code></pre></td></tr></table></figure></li><li><p>因为是用<code>next.js</code>所以不熟悉的还得看看官方文档 <a href="https://nextjs.frontendx.cn/" target="_blank" rel="noopener">https://nextjs.frontendx.cn/</a></p><p> 创建文件<code>pages</code>并在下面新建<code>index.js</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const Index &#x3D; () &#x3D;&gt; (<br>  &lt;div&gt;<br>    &lt;p&gt;Sample app using React and Next.js&lt;&#x2F;p&gt;<br>  &lt;&#x2F;div&gt;<br>);<br><br>export default Index;<br></code></pre></td></tr></table></figure><p> 添加相关运行命令打开<code>package.json</code>文件添加</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;scripts&quot;: &#123;<br>    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,<br>    &quot;dev&quot;: &quot;next&quot;,<br>    &quot;build&quot;: &quot;next build&quot;,<br>    &quot;start&quot;: &quot;next start&quot;<br>  &#125;<br>&#125;<br>&#96;&#96;&#96; <br><br>运行开发环境<br></code></pre></td></tr></table></figure><p> npm run dev</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">    <br>    到这里应该是创建一个&#96;next.js&#96;项目然后接下来对接到&#96;Shopify&#96;<br>4. 使用&#96;ngrok&#96;暴露出去自己的&#96;3000&#96;端口因为&#96;next.js&#96;启动的默认是&#96;3000&#96;端口<br></code></pre></td></tr></table></figure><p> ngrok http 3000</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">    ![](https:&#x2F;&#x2F;user-gold-cdn.xitu.io&#x2F;2020&#x2F;1&#x2F;17&#x2F;16fb29415dbff038?w&#x3D;976&amp;h&#x3D;519&amp;f&#x3D;png&amp;s&#x3D;30962)<br>    然后在自己创建的应用中设置中添加&#96;对应的url&#96;（得用&#96;https&#96;的）就在上面所说的填写&#96;url&#96;<br>    <br>5.  使用&#96;node&#96;的 &#96;koa&#96;来进行渲染页面操作<br>    1. 创建&#96;env&#96;环境变量文件并写入在上面创建的应用的&#96;KEY&#96;<br></code></pre></td></tr></table></figure><pre><code>SHOPIFY_API_KEY=&apos;YOUR API KEY FROM SHOPIFY PARTNERS DASHBOARD&apos;SHOPIFY_API_SECRET_KEY=&apos;YOUR API SECRET KEY FROM SHOPIFY PARTNERS DASHBOARD&apos; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2. 安装相关&#96;Shopify&#96;的验证&#96;koa&#96;中间件<br></code></pre></td></tr></table></figure>npm install --save koa @shopify/koa-shopify-auth dotenv koa-session isomorphic-fetch<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3. 创建&#96;server.js&#96;写入相关验证代码<br></code></pre></td></tr></table></figure>require(&apos;isomorphic-fetch&apos;);const dotenv = require(&apos;dotenv&apos;);const Koa = require(&apos;koa&apos;);const next = require(&apos;next&apos;);const { default: createShopifyAuth } = require(&apos;@shopify/koa-shopify-auth&apos;);const { verifyRequest } = require(&apos;@shopify/koa-shopify-auth&apos;);const session = require(&apos;koa-session&apos;);dotenv.config();// graphql的相关中间件const { default: graphQLProxy } = require(&apos;@shopify/koa-shopify-graphql-proxy&apos;); const { ApiVersion } = require(&apos;@shopify/koa-shopify-graphql-proxy&apos;);const port = parseInt(process.env.PORT, 10) || 3000;const dev = process.env.NODE_ENV !== &apos;production&apos;;const app = next({ dev });const handle = app.getRequestHandler();const { SHOPIFY_API_SECRET_KEY, SHOPIFY_API_KEY } = process.env; // 环境变量里读取 api-key与api-secret-keyapp.prepare().then(() =&gt; {  const server = new Koa();  server.use(session(server));  server.keys = [SHOPIFY_API_SECRET_KEY];  server.use(    createShopifyAuth({      apiKey: SHOPIFY_API_KEY,      secret: SHOPIFY_API_SECRET_KEY,       scopes: [&apos;read_products&apos;, &apos;write_products&apos;], //填写相关应用api相关请求的权限      afterAuth(ctx) {        const { shop, accessToken } = ctx.session; // 通过session拿取相关商店地址以及请求api需要的accessToken        ctx.cookies.set(&apos;shopOrigin&apos;, shop, { httpOnly: false });         ctx.redirect(&apos;/&apos;); // 重定向到index首页      },    }),  );  server.use(verifyRequest());  server.use(async (ctx) =&gt; {    await handle(ctx.req, ctx.res);    ctx.respond = false;    ctx.res.statusCode = 200;    return  });  server.use(graphQLProxy({version: ApiVersion.October19})) // 这里填写相关api的版本  server.listen(port, () =&gt; {    console.log(`&gt; Ready on http://localhost:${port}`); // 监听端口  });});<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4. 修改&#96;package.json&#96;文件使用我们的&#96;server.js&#96;来启动项目<br></code></pre></td></tr></table></figure>{  &quot;scripts&quot;: {    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;dev&quot;: &quot;node server.js&quot;,    &quot;start&quot;: &quot;NODE_ENV=production node server.js&quot;,    &quot;build&quot;: &quot;next build&quot;,  }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">现在我们启动项目并且用&#96;ngrok&#96;暴露出去的域名就能看到<br><br>![](https:&#x2F;&#x2F;user-gold-cdn.xitu.io&#x2F;2020&#x2F;1&#x2F;17&#x2F;16fb2a914762cace?w&#x3D;434&amp;h&#x3D;214&amp;f&#x3D;png&amp;s&#x3D;6256)<br>这里还要在域名的&#96;shop&#96;填写我们的商店地址例如我自己的：<br></code></pre></td></tr></table></figure>https://e44132cd.ngrok.io/auth/inline?shop=jetbn.myshopify.com<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">        一切填写就绪之后一&#96;enter&#96;页面就自动跳转了。<br>        <br>        最后展示的页面：<br>        ![](https:&#x2F;&#x2F;user-gold-cdn.xitu.io&#x2F;2020&#x2F;1&#x2F;17&#x2F;16fb2af2f6b051c0?w&#x3D;1317&amp;h&#x3D;551&amp;f&#x3D;png&amp;s&#x3D;32089)<br><br>## 折腾其他框架尝试<br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;前前后后都是使用&#96;React&#96;的&#96;next.js&#96;开发了两三个应用，感觉就是开发的时候太麻烦了，总要内网穿透，而且展示的页面都是&#96;Shopify&#96;的的自己平台上，而且开发写完代码等它响应过来还很慢。就这原因我又开始折腾了寻求其他的方案看看有没有能在自己开发完了再到它那上面，而且让验证&#96;Shopify&#96;的一系列操作让我们的后端小哥来操作。最终我前端选择&#96;Vue&#96;并且验证都放后端了，这样我就能像平常开发&#96;Vue&#96;项一样了。<br><br>下面介绍下我纯前端进行&#96; Shopify&#96;的验证操作使用&#96;vue&#96;。（前提要素内网穿透，不过开发的时候不需要）<br><br>1. 添加安装应用路由<br></code></pre></td></tr></table></figure></code></pre><p>  {</p><pre><code>path: &apos;/shopify/install&apos;,beforeEnter(to, _from, next) {  if (to.query.shop) {  //要在域名后添加开发的商店地址      const shop = to.query.shop,      scopes = &apos;read_orders,read_products,write_products&apos;, // api权限      // 重定向地址就是在创建应用的时候填写的第二个（重定向URL可以自己随意写了），我这里是域名加/shopify/auth      redirect_uri = &apos;https://&apos; + process.env.VUE_APP_ROOT_URL + &apos;/shopify/auth&apos;,       // 拼接安装应用地址需要SHOPIFY_API_KEY我填写在我的.env文件中了      install_url =            &apos;http://&apos; + shop + &apos;/admin/oauth/authorize?client_id=&apos; +            process.env.VUE_APP_SHOPIFY_API_KEY +            &apos;&amp;scope=&apos; + scopes + &apos;&amp;redirect_uri=&apos; + redirect_uri    // 本地跳转安装地址    window.location = install_url  } else {    next({ path: &apos;/error&apos; })  }}</code></pre><p>   },</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">    <br>2. 重定向验证路由<br></code></pre></td></tr></table></figure><p>   {</p><pre><code>path: &apos;/shopify/auth&apos;,beforeEnter(to, _from, next) {// 通过回调的url获取相关的参数  const shop = to.query.shop,    hmac = to.query.hmac,    code = to.query.code// 使用SHOPIFY_API_SECRET_KEY验证 并且之后拿取access_token（这步没写）  if (shop &amp;&amp; hmac &amp;&amp; code) {    const map = Object.assign({}, to.query)    delete map[&apos;signature&apos;]    delete map[&apos;hmac&apos;]    const message = querystring.stringify(map)    const encrypted =      crypto.createHmac(&apos;sha256&apos;, process.env.VUE_APP_SHOPIFY_API_SECRET_KEY)            .update(message)            .digest(&apos;hex&apos;)    // const providedHmac =  Buffer.from(hmac, &apos;utf-8&apos;)    // const generatedHash = Buffer.from(encrypted, &apos;utf-8&apos;)    let hashEquals = false    try {      // later: Auth fails with `crypto.timingSafeEqual`      // hashEquals = crypto.timingSafeEqual(generatedHash, providedHmac)      hashEquals = hmac === encrypted    } catch (e) {      hashEquals = false    }    if (!hashEquals) {      next({ path: &apos;/error&apos; })    } else {      next(&apos;/&apos;)    }  } else {    next({ path: &apos;/error&apos; })  }}</code></pre><p>   }</p><pre><code>`Vue`这相关的验证方案也是从`Github`上面捞的，特地记录下。具体地址忘了，有需要自己可以搜搜。🤣</code></pre></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&ensp;&ensp;&ensp;&ensp;经过一段时间的熟悉，自己也算又掌握一项新东西了。刚开始这个<code>Shopify</code>插件应用开发真的是巨坑啊，虽然官方有文档流程，但是都是英文的而且基础的搭建都是<code>api</code>都是用<code>GraphQL</code>然后我自己尝试了都是各种超时操作，请求不到最后就自己弃用了，用<code>ResfulApi</code>。然后就是遇到问题啊啥的都跟本搜不到，我想着这也太难了我，然后只能硬着头皮去官方文档里找，最后到现在也算是起起伏伏终于都熟悉了，搞懂了。</p><p>&ensp;&ensp;&ensp;&ensp; 这之后发现了英文水平太重要了。虽然开发文档基本内容能看懂，但是都是半猜半疑的，然后翻译一波。（各种不准确），然后开始补英文吧。🤞</p><p>&ensp;&ensp;&ensp;&ensp;  最后放上几个<code>Shopify</code>开发常用的官方文档地址：</p><p>&ensp;&ensp;&ensp;&ensp;Shopify Partners(创建应用查看应用):  <a href="https://vue-composition-api-rfc.netlify.com" target="_blank" rel="noopener">https://vue-composition-api-rfc.netlify.com</a></p><p>&ensp;&ensp;&ensp;&ensp;Shopify Developers(官方开发文档):   <a href="https://developers.shopify.com" target="_blank" rel="noopener">https://developers.shopify.com</a>（搭建参考文档）</p><p>&ensp;&ensp;&ensp;&ensp;Shopify Polaris(官方UI框架):   <a href="https://polaris.shopify.com" target="_blank" rel="noopener">https://developers.shopify.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/16/16facfbcc2c3ad20?w=500&amp;h=144&amp;f=png&amp;s=18435&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class
      
    
    </summary>
    
    
      <category term="Web前端" scheme="http://jetBn.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://jetBn.github.io/categories/Web%E5%89%8D%E7%AB%AF/React/"/>
    
    
      <category term="Shopify" scheme="http://jetBn.github.io/tags/Shopify/"/>
    
      <category term="React" scheme="http://jetBn.github.io/tags/React/"/>
    
      <category term="Next.js" scheme="http://jetBn.github.io/tags/Next-js/"/>
    
  </entry>
  
  <entry>
    <title>mpvue入坑记录</title>
    <link href="http://jetbn.github.io/2020/04/29/mpvue%E5%85%A5%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://jetbn.github.io/2020/04/29/mpvue%E5%85%A5%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2020-04-29T02:57:09.000Z</published>
    <updated>2020-04-30T02:39:23.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用MpVue开发小程序记录"><a href="#使用MpVue开发小程序记录" class="headerlink" title="使用MpVue开发小程序记录"></a>使用MpVue开发小程序记录</h2><p>&#160; &#160; &#160; &#160; 当下轻应用，遍布各大互联网公司。像百度、支付宝、微信、字节都是有自己的小程序形式，就现在QQ也推出了小程序的形式，像这种轻应用又不需要安装，就能打开，而且也类似了app形式。当然相对于形式也不能说不会开发吧，该学的还是得学。所以现在也有很多基于框架延伸而出的打包生成多个平台的小程序，例如 基于react的taro、还有wepy、mpvue目前应该这个三个最火热了，然后我尝试了mpvue开发了过程不说坑还是有的。自己也是一步步解决，所以决定记录一下。</p><ol><li><p>首先就搭建了项目使用相关环境自己也是全部尝试了一遍安装了<code>scss</code>环境以及<code>vuex</code>，好像有解决的<code>vue-router</code>自己没有尝试.</p><p>1.1  首先讲下<code>scss</code>的<code>mixin</code>我在全局的时候引入在页面页面中能用，为什么在组件中用不了这是啥我也不是清楚。还有就是我在<code>scss</code>中使用<code>font</code>字体的问题，在此中我通过本地的方式引入发现就是加载不了，后来寻找方案在交流群中得知是得将文件放在<code>static</code>文件下并且使用绝对路径的方式引用，是有效不报错了。但是小程序打包又上传了不了，后来我就直接干脆放服务器上了，再通过引用，这下总没问题了。</p><p>1.2 再次就是<code>vuex</code>在<code>main.js</code>中引用在<code>vue</code>的原型上加而不是像<code>vue-cli</code>中使用一样 直接写在<code>new VUE</code>中。</p><p>在main.js中定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">import Vue from &#39;vue&#39;<br>import App from &#39;.&#x2F;App&#39;<br>import store from &#39;.&#x2F;store&#39;<br><br>Vue.config.productionTip &#x3D; false<br>App.mpType &#x3D; &#39;app&#39;<br>Vue.prototype.$store &#x3D; store<br><br>const app &#x3D; new Vue(App)<br>app.$mount()<br></code></pre></td></tr></table></figure><p>在页面中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">this.$store.state<br></code></pre></td></tr></table></figure><p>也可以使用vuex的mapState引用某个state</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 头部导入<br>import &#123; mapState &#125; from &#39;vuex&#39;<br><br>&#x2F;&#x2F; 在计算属性中<br><br>...mapState([<br>  &#39;carBrandCityPrev&#39; &#x2F;&#x2F; 对应stae中定义的<br>]),<br></code></pre></td></tr></table></figure></li><li><p>自定义TabBar自己刚开始使用也是一头水雾，微信小程序更新的很快。我之前写的一个小程序用的是原生开发的时候，那时候还没有什么定义TabBar啊、导航栏、组件啊什么的。后来我也是看了下官方的demo以及github中mpuve项目的issue中找解决方案，最终还是直接上手搞了一波。中途也是坎坎坷坷。</p><blockquote><p>贴个自定义tabbar地址: <a href="https://github.com/jetBn/mpvue-custom-tab-bar" target="_blank" rel="noopener">https://github.com/jetBn/mpvue-custom-tab-bar</a></p></blockquote></li><li><p>小程序中获取地理位置授权问题，只有在第一次进入的会提示是否授权如果拒绝了授权第二进入都不会授权，都会走授权位置的<code>fail</code>方法,所以这个原因问题。我们只能是通过微信的获取用户的当前设置检查 <code>wx.getSetting</code>api去检查当前是否授权，通过此方法放在<code>fail</code>方法中检测当前是否开启授权地理位置，如果没有重新调用地理位置授权的方法。</p><p> 相关检查是否授权方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; fn指相关重新授权的方法<br>  export function checkGetLocationPermison (fn) &#123;<br>    wx.getSetting(&#123;<br>      success: (res) &#x3D;&gt; &#123;<br>        const status &#x3D; res.authSetting<br>        if (!status[&#39;scope.userLocation&#39;]) &#123;<br>          wx.showModal(&#123;<br>            title: &#39;是否授权当前位置&#39;,<br>            content: &#39;需要获取您的地理位置，请确认授权，否则地图功能将无法使用获取不了优惠券信息&#39;,<br>            success: (subRes) &#x3D;&gt; &#123;<br>              if (subRes.confirm) &#123;<br>                wx.openSetting(&#123;<br>                  success: (subRes) &#x3D;&gt; &#123;<br>                    if (subRes.authSetting[&#39;scope.userLocation&#39;] &#x3D;&#x3D;&#x3D; true) &#123;<br>                      wx.showToast(&#123;<br>                        title: &#39;授权成功&#39;,<br>                        icon: &#39;success&#39;,<br>                        duration: 1000<br>                      &#125;)<br>                      fn()<br>                    &#125; else &#123;<br>                      wx.showToast(&#123;<br>                        title: &#39;授权失败&#39;,<br>                        icon: &#39;success&#39;,<br>                        duration: 1000<br>                      &#125;)<br>                    &#125;<br>                  &#125;<br>                &#125;)<br>              &#125;<br>            &#125;<br>          &#125;)<br>        &#125;<br>      &#125;,<br>      fail: () &#x3D;&gt; &#123;<br>        wx.showToast(&#123;<br>          title: &#39;调用授权窗口失败&#39;,<br>          icon: &#39;success&#39;,<br>          duration: 1000<br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>在mpvue是axios全局处理请求返回值以及请求头设置等等。在<code>npm i axios qs</code>后新建<code>request.js</code>文件，引入<code>qs</code>处理<code>axios</code>中post请求，然后微信小程序中是使用<code>wx.request</code>发送请求的并不是直接使用axios就可以的，所以使用<code>axios</code>的<code>adapter</code> 属性进行我们的请求操作。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 创建axios实例<br>const Axios &#x3D; axios.create(&#123;<br>  baseURL: &#39;&#39;, &#x2F;&#x2F; 设置请求域名地址<br>  timeout: 1000 * 60 * 10, &#x2F;&#x2F; 设置请求超时时间<br>  responseType: &#39;json&#39; &#x2F;&#x2F; 设置返回值类型<br>&#125;)<br><br><br>&#x2F;&#x2F; 然后使用Axios实例的adapter进行封装微信请求<br>Axios.defaults.adapter &#x3D; (config) &#x3D;&gt; &#123;<br>  return new Promise((resolve, reject) &#x3D;&gt; &#123;<br>    let data &#x3D; config.method &#x3D;&#x3D;&#x3D; &#39;get&#39; ? config.params : qs.stringify(config.params)<br>    wx.request(&#123;<br>      url: config.url,<br>      method: config.method,<br>      header: &#123;&#39;Content-type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;&#125;,<br>      data,<br>      success: (res) &#x3D;&gt; (resolve(res)),<br>      fail: (err) &#x3D;&gt; (reject(err))<br>    &#125;)<br>  &#125;)<br>&#125;<br><br>&#x2F;&#x2F; 请求拦截<br>Axios.interceptors.request.use((request) &#x3D;&gt; &#123;<br>  return request<br>&#125;, (error) &#x3D;&gt; &#123;<br>  return Promise.reject(error)<br>&#125;)<br><br>&#x2F;&#x2F; 响应拦截<br>Axios.interceptors.response.use((response) &#x3D;&gt; &#123;<br>    return response<br>&#125;, (error) &#x3D;&gt; &#123;<br>     return Promise.reject(error)<br>&#125;)<br><br>&#x2F;&#x2F; 导出响应的方法<br>export function fetch (options) &#123;<br>  return new Promise((resolve, reject) &#x3D;&gt; &#123;<br>    Axios(options)<br>      .then(response &#x3D;&gt; &#123;<br>        resolve(response)<br>      &#125;)<br>      .catch(error &#x3D;&gt; &#123;<br>        reject(error)<br>      &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>相关自定义头部导航栏根据相关设备判断设置高度，相关计算是顶部状态栏的高度加上相关定义的高度。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;微信获取相关设备信息的API<br>wx.getSystemInfo(&#123;<br>  success (system) &#123;<br>    &#x2F;&#x2F; console.log(&#96;system:&#96;, system)<br>    self.statusBarHeight &#x3D; system.statusBarHeight<br>    self.platform &#x3D; system.platform<br>    const windowHeight &#x3D; system.windowHeight<br>    let platformReg &#x3D; &#x2F;ios&#x2F;i<br>    if (platformReg.test(system.platform)) &#123;<br>      self.titleBarHeight &#x3D; 44  &#x2F;&#x2F; iso的高度<br>    &#125; else &#123;<br>      self.titleBarHeight &#x3D; 48  &#x2F;&#x2F;android 的高度<br>    &#125;<br>    self.navBarHeight &#x3D; self.statusBarHeight + self.titleBarHeight<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>mpvue中使用组件式封装 然后是内容使用插槽形式，在使用组件的使用插槽内的内容数据更新页面不会实时更新 。（父组件插槽内容块中使用的也是组件封装的组件）（问题1）。然后我使用了 不封装组件 直接写页面样式点击组件的事件会触发插槽中的事件？？？（问题2） 事件跟插槽中的事件不在同一个div中。最后就是不用插槽才解决了上述问题1，2</p></li><li><p><code>npm run dev</code> 会卡在<code>node build/dev-server.js wx</code> 最后我自己也是在官方的github仓库中的<code>issu</code>中找到解决方案在build文件夹的<code>build.js</code>中<code>require(&#39;./check-versions&#39;)()</code>注释掉然后也就能正常运行了。具体的好像是在经过<code>check-versions</code>函数的时候执行特别的慢。</p></li></ol><p>&#160; &#160; &#160; &#160;最后总结下<code>MpVue</code>这个相对于<code>vue</code>针对于小程序的框架，大部分都是使用<code>vue</code>相关语法所以对于熟悉<code>vue</code>的来说还是很容易上手的。开发效率也还可以。感觉会使用<code>vue</code>再次熟悉微信小程序官方的API开发效率还是很高的，不过还是有挺多坑的，我这边坑可能是没有遇到很多。很幸运，具体的相关的语法情况可以对应官方网站的介绍情况。</p><p>&#160; &#160; &#160; &#160;最后附上相关网站地址：</p><p>&#160; &#160; &#160; &#160;官方网站：<a href="http://mpvue.com" target="_blank" rel="noopener">http://mpvue.com</a></p><p>&#160; &#160; &#160; &#160;github相关仓库地址： <a href="https://github.com/Meituan-Dianping/mpvue" target="_blank" rel="noopener">https://github.com/Meituan-Dianping/mpvue</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用MpVue开发小程序记录&quot;&gt;&lt;a href=&quot;#使用MpVue开发小程序记录&quot; class=&quot;headerlink&quot; title=&quot;使用MpVue开发小程序记录&quot;&gt;&lt;/a&gt;使用MpVue开发小程序记录&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;
      
    
    </summary>
    
    
      <category term="Web前端" scheme="http://jetBn.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://jetBn.github.io/categories/Web%E5%89%8D%E7%AB%AF/Vue/"/>
    
      <category term="小程序" scheme="http://jetBn.github.io/categories/Web%E5%89%8D%E7%AB%AF/Vue/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://jetBn.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
